#!/usr/bin/env python3
'''Show packages whose spec files specify an RPM version that does not exist

Placed into the public domain by
Daniel Fandrich <dan@coneharvesters.com>
Started October 2014

Usage: spec-rpm-mismatch >report.html 2>errors.log
 within directory prepared by checkout-all-specs

TODO:
    %autopatch seems to cause patches to be loaded from SOURCES and gives warnings if not

    highlight in the html mismatch section packages not ending in .mga8

    fix warnings from .spec files with weird macros calling external programs
'''

import collections
import concurrent.futures
import enum
import glob
from html import escape
from logging import info, warning, error, fatal, basicConfig, INFO
import os
import re
import shlex
import stat
import sys
import textwrap
import time
from typing import Dict, List, Set, Tuple


basicConfig(level=INFO, format='%(levelname)s:%(message)s')

TEXT_REPORT = False

# Parallelize parsing with twice the number of available cores
PARALLEL_THREADS = 2 * len(os.sched_getaffinity(0))

#SRPM_SOURCE_TEMPLATE = 'ftp://distrib-coffee.ipsl.jussieu.fr/pub/linux/Mageia/distrib/%(version)s/SRPMS/%(media)s/%(section)s/'
#SRPM_SOURCE_TEMPLATE = 'ftp://ftp.uni-erlangen.de/mirrors/Mageia/distrib/%(version)s/SRPMS/%(media)s/%(section)s/'
#SRPM_SOURCE_TEMPLATE = 'ftp://mirror.tuxinator.org/mageia/distrib/%(version)s/SRPMS/%(media)s/%(section)s/'
SRPM_SOURCE_TEMPLATE = 'ftp://ftp5.gwdg.de/pub/linux/mageia/distrib/%(version)s/SRPMS/%(media)s/%(section)s/'
#SRPM_SOURCE_TEMPLATE = 'ftp://mirror.netcologne.de/mageia/distrib/%(version)s/SRPMS/%(media)s/%(section)s/'
SRPM_VERSION = 'cauldron'
SRPM_MEDIAS = ['tainted', 'nonfree', 'core']
SRPM_SECTION = 'release'
SRPM_DISTRO_RELEASE = '8'  # mgaX

class SpecStyle(enum.IntEnum):
    SPEC_STYLE_UNKNOWN = enum.auto()
    SPEC_STYLE_MASSIVE = enum.auto()
    SPEC_STYLE_INDIVIDUAL = enum.auto()
    SPEC_STYLE_SPEC_ONLY = enum.auto()

SPEC_STYLE_NAME = {
    SpecStyle.SPEC_STYLE_UNKNOWN: 'unknown',
    SpecStyle.SPEC_STYLE_MASSIVE: 'massive checkout',
    SpecStyle.SPEC_STYLE_INDIVIDUAL: 'individual packages',
    SpecStyle.SPEC_STYLE_SPEC_ONLY: 'spec only',
}

UNKNOWN_PACKAGER = '?'

SVNWEB_URL_TEMPLATE = 'https://svnweb.mageia.org/packages/%s/%s/current/SPECS/%s.spec'

HTML_HEADER = textwrap.dedent('''
    <!DOCTYPE html>
    <html><head>
    <meta name="GENERATOR" content="spec-rpm-mismatch">
    <title>Spec Build Report</title>
    <style type="text/css">
      .release {
        background-color: #f0f0ff;
      }
    </style>
    </head>
    <body>
''')

HTML_FOOTER = textwrap.dedent('''
    </body>
    </html>
''')


def get_packagers() -> Dict[str, str]:
    'Retrieve a dict containing packagers for each package'
    packagers = collections.defaultdict(lambda : UNKNOWN_PACKAGER)
    cmd = 'mgarepo maintdb get'
    info("Running: %s", cmd)
    pipe = os.popen(cmd, 'r')
    while True:
        line = pipe.readline()
        if not line:
            break
        package, packager = tuple(line.strip().split())
        packagers[package] = packager
    if pipe.close():
        error('Problem retrieving the maintdb')
    return packagers


PACKAGE_RE = re.compile(r'^(.*)(-[\w\.+]+-[\w\.]+\.mga(\d+))(\.\w+)?\.src\.rpm$')


def package_name(rpm: str) -> str:
    'Determine package name from RPM file name'
    match = PACKAGE_RE.match(rpm)
    if match:
        return match.group(1)
    return ''


def rpm_base_name(rpm: str) -> str:
    'Determine name + version + release from RPM file name'
    match = PACKAGE_RE.match(rpm)
    if match:
        return match.group(1) + match.group(2)
    return ''


PACKAGE_BASE_RE = re.compile(r'^(.*)(-[\w\.+]+)-([\w\.]+)\.mga(\d+)')


def rpm_versions(rpm_base: str) -> Tuple[str, str, str]:
    '''Determine name, version, release from an RPM base name

    Return: (name, version, release)
    '''
    match = PACKAGE_BASE_RE.match(rpm_base)
    if match:
        return (match.group(1), match.group(2), match.group(3))
    return ('', '', '')


def get_local_package_list() -> List[str]:
    'Get a list of local packages with spec files to check'
    spec_packages = glob.glob('*')
    return [f for f in spec_packages if stat.S_ISDIR(os.stat(f).st_mode)]


def determine_spec_tree_style(package: str) -> int:
    'Figure out why kind of style of SVN checkout is in use'
    try:
        if stat.S_ISDIR(os.stat(os.path.join(package, 'current', 'SPECS')).st_mode):
            return SpecStyle.SPEC_STYLE_MASSIVE
    except OSError:
        pass

    try:
        if stat.S_ISDIR(os.stat(os.path.join(package, 'SPECS')).st_mode):
            return SpecStyle.SPEC_STYLE_INDIVIDUAL
    except OSError:
        pass

    try:
        if stat.S_ISREG(os.stat(os.path.join(package, package + '.spec')).st_mode):
            return SpecStyle.SPEC_STYLE_SPEC_ONLY
    except OSError:
        pass

    return SpecStyle.SPEC_STYLE_UNKNOWN


def retrieve_dir_contents(url: str) -> List[str]:
    'Return a directory listing of the remote URL'
    listing = []
    cmd = 'curl -s -l --ftp-method SINGLECWD --ssl ' + shlex.quote(url)
    info("Running: %s", cmd)
    pipe = os.popen(cmd, 'r')
    while True:
        line = pipe.readline()
        if not line:
            break
        listing.append(line.strip())
    if pipe.close():
        error('Cannot retrieve files at %s', url)
    return listing


def retrieve_all_packages() -> Tuple[Set[str], Dict[str, str]] :
    '''Retrieve a list of all packages available in the distribution.

    This could be changed to use the urpmi synthesis files instead.
    '''
    all_rpms = set()
    all_packages = {}

    # Only some schemes are supported due to the need for curl's -l flag
    if SRPM_SOURCE_TEMPLATE.split(':')[0] not in ('ftp', 'ftps'):
        error('SRPM URL type %s not supported', SRPM_SOURCE_TEMPLATE)
    else:
        for media in SRPM_MEDIAS:
            url = SRPM_SOURCE_TEMPLATE % {'version': SRPM_VERSION, 'media': media, 'section': SRPM_SECTION}
            listing = retrieve_dir_contents(url)
            if not listing:
                raise RuntimeError('Error retrieving listing from ' + url)

            rpm_re = re.compile(r'^.*\.rpm$')
            rpms = [f for f in listing if rpm_re.match(f)]
            if not rpms:
                error('Warning: No results from ' + url)

            info('%d packages found in media %s', len(rpms), media)

            for rpm in rpms:
                package = package_name(rpm)
                if not package:
                    error('Cannot determine package name for ' + rpm)
                    continue
                rpm_base = rpm_base_name(rpm)
                if not rpm_base:
                    error('Cannot determine base name for ' + rpm)
                    continue
                all_packages[package] = rpm_base
                all_rpms.add(rpm_base)

    return all_rpms, all_packages


def get_srpm_name_stub_from_spec(specfile: str) -> str:
    '''Determine the start of the SRPM name created by the given spec file.

    This returns a name like 'foo-1.23-4'
    '''
    # %dist includes the mgaX version of the current machine by default, which
    # might not match that of SRPM_DISTRO_RELEASE, so construct the version
    # ourselves.
    cmd = 'rpmspec -q -D"dist .mga"%s --queryformat "%%{NAME}-%%{VERSION}-%%{RELEASE}\n" %s' % \
            (shlex.quote(SRPM_DISTRO_RELEASE), shlex.quote(specfile))
    #info("Running: %s", cmd)
    pipe = os.popen(cmd, 'r')
    # There may be many RPMs generated, but the one is the one with the SRPM
    line = pipe.readline()
    if not line:
        return ''
    _ = pipe.read()  # ignore the rest
    if pipe.close():
        error('Cannot parse spec file %s', specfile)
        return ''
    return line.strip()


def make_spec_path(package: str, spec_style: int) -> str:
    if spec_style == SpecStyle.SPEC_STYLE_MASSIVE:
        return os.path.join(package, 'current', 'SPECS', package + '.spec')
    elif spec_style == SpecStyle.SPEC_STYLE_INDIVIDUAL:
        return os.path.join(package, 'SPECS', package + '.spec')
    elif spec_style == SpecStyle.SPEC_STYLE_SPEC_ONLY:
        return os.path.join(package, package + '.spec')
    raise RuntimeError('Unsupported spec style %d' % spec_style)


class PackageProcessor:

    def __init__(self, all_rpms: Set[str], all_packages: Dict[str, str], spec_style: int):
        self.all_rpms = all_rpms
        self.all_packages = all_packages
        self.spec_style = spec_style

        self.no_srpm_file = []  # type: List[str]
        self.errors = []  # type: List[str]
        self.version_mismatch = []  # type: List[Tuple[str, str, str]]
        self.version_match = []  # type: List[Tuple[str, str]]

    def process_package(self, package: str):
        spec_path = make_spec_path(package, self.spec_style)
        if package not in self.all_packages:
            self.no_srpm_file.append(package)
            return
        srpm_name = get_srpm_name_stub_from_spec(spec_path)
        if not srpm_name:
            error('Could not determine name stub for %s', spec_path)
            self.errors.append(package)
            return
        # Some RPMs define distro_section which appends the section to the RPM
        # base name (e.g. lgeneral-1.2.3-3.mga5.nonfree). Strip this off before
        # using it so all names are canonical.
        canon_srpm_name = rpm_base_name(srpm_name + '.src.rpm')
        if not canon_srpm_name:
            error('Could not determine base name for %s.src.rpm', srpm_name)
            self.errors.append(package)
            return
        if canon_srpm_name not in self.all_rpms:
            self.version_mismatch.append((package, self.all_packages[package], canon_srpm_name))
        else:
            self.version_match.append((package, canon_srpm_name))

    def sort(self):
        self.no_srpm_file.sort()
        self.errors.sort()
        self.version_mismatch.sort(key=lambda x: x[0])
        self.version_match.sort(key=lambda x: x[0])

    def print_text_report(self, packagers: Dict[str, str]):
        print()
        print('Packages with no associated SRPM file on the server')
        for package in self.no_srpm_file:
            print(packagers[package], package)

        print()
        print('Could not determine version number from these packages')
        for package in self.errors:
            print(packagers[package], package)

        print()
        print('Version missing on server')
        for package, have_name, should_have in self.version_mismatch:
            print(packagers[package], package, have_name, should_have)

        if True:
            print()
            print('Version match on server')
            for package, srpm_name in self.version_match:
                print(packagers[package], srpm_name)

    def print_html_report(self, packagers: Dict[str, str]):
        print(HTML_HEADER)
        print(f'<h1>{SRPM_VERSION} (mga{SRPM_DISTRO_RELEASE}) Spec Build Report as of {time.strftime("%Y-%m-%d")}</h1>')

        if self.no_srpm_file:
            print('<a href="#no_rpm">Missing RPMs</a><br>')

        print('<a href="#wrong_version">Wrong RPM version</a><br>')

        if self.errors:
            print('<a href="#errors">Spec parsing errors</a><br>')

        if self.version_match:
            print('<a href="#match_version">Matching RPM versions</a><br>')

        if self.no_srpm_file:
            print(textwrap.dedent(f'''
                <a name="no_rpm"></a>
                <h2>Spec files with no matching RPM of any version</h2>

                There is no package SRPM in the {SRPM_VERSION} release matching the associated
                .spec file. This may be because the package was imported but never
                successfully built, or because the package has been obsoleted and
                removed from the distribution but the .spec file was never moved to
                packages/obsolete.
                <p>
                ({len(self.no_srpm_file)} packages)
                <table>
                <tr>
                  <th>Maintainer</th>
                  <th>Package</th>
                </tr>
            '''))
            for package in self.no_srpm_file:
                url = SVNWEB_URL_TEMPLATE % (SRPM_VERSION, escape(package), escape(package))
                print(textwrap.dedent(f'''
                    <tr>
                      <td>{escape(packagers[package])}</td>
                      <td><a href="{url}">{escape(package)}</a></td>
                    </tr>
                '''))
            print('</table>')

        print(textwrap.dedent(f'''
            <a name="wrong_version"></a>
            <h2>Wrong RPM version</h2>

            The latest version of the SRPM does not match the version in the .spec
            file.  This may be because no-one has submitted the latest version to be
            built, or because the last attempted build failed. Shaded lines are
            packages with equal versions that differ only in the release number.
            <p>
            ({len(self.version_mismatch)} packages)
            <table>
            <tr>
              <th>Maintainer</th>
              <th>RPM version</th>
              <th>Spec version</th>
            </tr>
         '''))
        for package, have_name, should_have in self.version_mismatch:
            _, have_ver, _ = rpm_versions(have_name)
            _, should_have_ver, _ = rpm_versions(should_have)
            match_class = ' class="release"' if have_ver == should_have_ver else ''
            url = SVNWEB_URL_TEMPLATE % (SRPM_VERSION, escape(package), escape(package))
            print(textwrap.dedent(f'''
                    <tr{match_class}>
                      <td>{escape(packagers[package])}</td>
                      <td>{escape(have_name)}</td>
                      <td><a href="{url}">{escape(should_have)}</a></td>
                    </tr>
                '''))
        print('</table>')

        if self.errors:
            print(textwrap.dedent(f'''
                <a name="errors"></a>
                <h2>Could not determine version number from these packages</h2>

                This could be due to a syntax error in the .spec file, a missing
                %include file (such files are not normally available to this reporting
                script so this is expected), a missing utility used in command
                substitution (BuildRequires: are not normally available to this
                reporting script so this is expected), a mismatch between the SVN
                directory and the .spec file name, or an internal error in the script
                generating this report.
                <p>
                ({len(self.errors)} packages)
                <table>
                <tr>
                  <th>Package</th>
                </tr>
            '''))
            for package in self.errors:
                url = SVNWEB_URL_TEMPLATE % (SRPM_VERSION, escape(package), escape(package))
                print(textwrap.dedent(f'''
                    <tr>
                      <td><a href="{url}">{escape(package)}</a></td>
                    </tr>
                '''))
            print('</table>')

        if self.version_match:
            print('''
            <a name="match_version"></a>
            <h2>Spec &amp; RPM versions match</h2>

            The version of the SRPM matches the version in the .spec file. This is
            the desired state, so these are the only packages without error.
            <p>
            ''')
            if len(self.version_match) > 300:
                print('%d spec files have matching RPMs (not shown)' % len(self.version_match))
            else:
                print(textwrap.dedent(f'''
                    ({len(self.version_match)} packages)
                    <table>
                    <tr>
                      <th>Maintainer</th>
                      <th>Spec/RPM version</th>
                    </tr>
                '''))
                for package, srpm_name in self.version_match:
                    print(textwrap.dedent(f'''
                        <tr>
                          <td>{escape(packagers[package])}</td>
                          <td>{escape(srpm_name)}</td>
                        </tr>
                    '''))
                print('</table>')

        print(HTML_FOOTER)



def main() -> int:
    spec_packages = get_local_package_list()
    if len(spec_packages) == 0:
        fatal('No package directories found')
        return 1

    canary_package = spec_packages[-1]
    spec_style = determine_spec_tree_style(canary_package)
    info('Spec file checkout style in use is %s' % SPEC_STYLE_NAME[spec_style])
    if spec_style == SpecStyle.SPEC_STYLE_UNKNOWN:
        return 1

    info('%d package directories found' % len(spec_packages))

    all_rpms, all_packages = retrieve_all_packages()

    info('%d total SRPM packages found on server' % len(all_packages))
    if len(all_packages) == 0:
        fatal('No packages found. Try a different mirror.')
        return 2

    packagers = get_packagers()
    if not packagers:
        warning('Packager list could not be retrieved. Packagers will not be shown.')
    info('%d packagers known' % len(packagers))

    proc = PackageProcessor(all_rpms, all_packages, spec_style)

    info('Starting check of spec files')
    spec_packages.sort()

    with concurrent.futures.ThreadPoolExecutor(max_workers=PARALLEL_THREADS) as executor:
        futures = (executor.submit(proc.process_package, package) for package in spec_packages)
        for n, future in enumerate(concurrent.futures.as_completed(futures)):
            if n % 100 == 0:
                # Provide some visual feedback on progress
                info('%d/%d (%d%%)', n, len(spec_packages), 100 * n / len(spec_packages))
            future.result()  # call this so reveal any exceptions

    proc.sort()
    if TEXT_REPORT:
        proc.print_text_report(packagers)
    else:
        proc.print_html_report(packagers)

    info('Report complete')

    return 0


if __name__=='__main__':
    sys.exit(main())
